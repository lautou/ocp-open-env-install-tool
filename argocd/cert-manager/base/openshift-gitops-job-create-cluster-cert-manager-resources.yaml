apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    argocd.argoproj.io/sync-options: Force=true
  name: create-cluster-cert-manager-resources
  namespace: openshift-gitops
spec:
  template:
    metadata:
      name: create-cluster-cert-manager-resources
    spec:
      containers:
        - name: create-cluster-cert-manager-resources
          image: quay.io/devfile/universal-developer-image:ubi8-latest
          command:
            - /bin/bash
            - '-c'
            - |
              #!/bin/bash
              # This script will wait for cert-manager to be fully operational,
              # handling race conditions by retrying if it fails to initialize correctly.
              set -e
              set -o pipefail

              CERT_MANAGER_NAMESPACE="cert-manager"
              CERT_MANAGER_CR_NAME="cluster"

              echo "Waiting for the cert-manager CRD (certmanagers.operator.openshift.io) to be established..."
              until oc get crd certmanagers.operator.openshift.io &>/dev/null; do
                sleep 5
              done
              echo "CRD established."

              # --- ROBUST VERIFICATION AND REPAIR LOOP ---
              while true; do
                echo "--- Starting new validation cycle for CertManager ---"
                
                echo "Waiting for CertManager CR '${CERT_MANAGER_CR_NAME}' to be created..."
                until oc get certmanager ${CERT_MANAGER_CR_NAME} &>/dev/null; do
                  sleep 10
                done
                echo "CertManager CR found."

                echo "Entering health check loop for CertManager components (timeout: 5 minutes)..."
                OVERALL_HEALTHY=false
                # Timeout loop: 30 attempts * 10s sleep = 300s = 5 minutes
                for i in $(seq 1 30); do
                  echo "Health check attempt ${i}/30..."
                  
                  # 1. Check cert-manager-controller deployment
                  if oc get deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager &>/dev/null; then
                    if oc wait deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager --for=condition=Available --timeout=0s &>/dev/null; then
                      CONTROLLER_STATUS="READY"
                    else
                      CONTROLLER_STATUS="WAITING FOR READY"
                    fi
                  else
                    CONTROLLER_STATUS="PENDING (Not created yet)"
                  fi

                  # 2. Check cert-manager-cainjector deployment
                  if oc get deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager-cainjector &>/dev/null; then
                    if oc wait deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager-cainjector --for=condition=Available --timeout=0s &>/dev/null; then
                      CAINJECTOR_STATUS="READY"
                    else
                      CAINJECTOR_STATUS="WAITING FOR READY"
                    fi
                  else
                    CAINJECTOR_STATUS="PENDING (Not created yet)"
                  fi
                  
                  # 3. Check cert-manager-webhook deployment
                  if oc get deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager-webhook &>/dev/null; then
                    if oc wait deployment -n ${CERT_MANAGER_NAMESPACE} cert-manager-webhook --for=condition=Available --timeout=0s &>/dev/null; then
                      WEBHOOK_DEPLOYMENT_STATUS="READY"
                    else
                      WEBHOOK_DEPLOYMENT_STATUS="WAITING FOR READY"
                    fi
                  else
                    WEBHOOK_DEPLOYMENT_STATUS="PENDING (Not created yet)"
                  fi
                  
                  # 4. Check that the webhook service has active endpoints.
                  # Use --ignore-not-found to prevent the script from exiting if the endpoints object doesn't exist yet.
                  WEBHOOK_ENDPOINTS=$(oc get endpoints -n ${CERT_MANAGER_NAMESPACE} cert-manager-webhook --ignore-not-found -o jsonpath='{.subsets[?(@.addresses)].addresses}')
                  if [[ -n "${WEBHOOK_ENDPOINTS}" ]]; then
                    WEBHOOK_SERVICE_STATUS="READY (Endpoints available)"
                  else
                    WEBHOOK_SERVICE_STATUS="PENDING (No endpoints)"
                  fi

                  # Print Status
                  echo "  - Controller Deployment: ${CONTROLLER_STATUS}"
                  echo "  - Cainjector Deployment: ${CAINJECTOR_STATUS}"
                  echo "  - Webhook Deployment:    ${WEBHOOK_DEPLOYMENT_STATUS}"
                  echo "  - Webhook Service:       ${WEBHOOK_SERVICE_STATUS}"

                  # Overall Health Decision
                  if [[ "${CONTROLLER_STATUS}" == "READY" && \
                        "${CAINJECTOR_STATUS}" == "READY" && \
                        "${WEBHOOK_DEPLOYMENT_STATUS}" == "READY" && \
                        "${WEBHOOK_SERVICE_STATUS}" == "READY (Endpoints available)" ]]; then
                    echo "SUCCESS: All CertManager components are healthy."
                    OVERALL_HEALTHY=true
                    break # Exit the 'for' loop
                  fi
                  
                  sleep 10
                done

                if [ "$OVERALL_HEALTHY" = "true" ]; then
                  echo "CertManager is fully operational. Proceeding with resource creation."
                  break # Exit the 'while' loop
                else
                  echo "FAILURE: CertManager did not become healthy after 5 minutes."
                  echo "Deleting CertManager CR '${CERT_MANAGER_CR_NAME}' to force a redeployment."
                  oc delete certmanager ${CERT_MANAGER_CR_NAME} --ignore-not-found
                  echo "Waiting 30 seconds before retrying..."
                  sleep 30
                fi
              done

              echo "Read the secret for AWS cloud provider"
              ACCESS_KEY=$(oc extract secret/aws-creds -n kube-system --keys aws_access_key_id --to -)
              SECRET_KEY=$(oc extract secret/aws-creds -n kube-system --keys aws_secret_access_key --to -)

              echo "Create the aws-acme secret"
              oc delete secret generic aws-acme -n ${CERT_MANAGER_NAMESPACE} --ignore-not-found
              oc create secret generic aws-acme -n ${CERT_MANAGER_NAMESPACE} --from-literal awsAccessKey=$ACCESS_KEY --from-literal awsSecretAccessKey=$SECRET_KEY

              INSTALL_CONFIG=$(oc extract cm/cluster-config-v1 --keys install-config --to - -n kube-system)
              CLUSTER_ISSUER_CLUSTER_TEMPLATE=$(oc extract cm/clusterissuer-cluster --keys cluster-clusterissuer-cluster.yaml --to - -n openshift-gitops)
              CERTIFICATE_INGRESS_TEMPLATE=$(oc extract cm/openshift-ingress-certificate-ingress --keys openshift-ingress-certificate-ingress.yaml --to - -n openshift-gitops)
              CERTIFICATE_API_TEMPLATE=$(oc extract cm/openshift-config-certificate-api --keys openshift-config-certificate-api.yaml --to - -n openshift-gitops)

              export REGION=$(echo "$INSTALL_CONFIG" | yq -r '.platform.aws.region' -)
              echo "REGION=$REGION"
              export BASEDOMAIN=$(echo "$INSTALL_CONFIG" | yq -r '.baseDomain' -)
              export CLUSTERNAME=$(echo "$INSTALL_CONFIG" | yq -r '.metadata.name' -)
              echo "CLUSTERNAME=$CLUSTERNAME"
              export TIMESTAMP=$(date +%s)
              echo "TIMESTAMP=$TIMESTAMP"
              
              echo "Applying ClusterIssuer..."
              echo "$CLUSTER_ISSUER_CLUSTER_TEMPLATE" \
                | yq -y '.spec.acme.solvers[0].dns01.route53.region = "'"$REGION"'"' - \
                | oc apply -f -

              echo "Applying Ingress Certificate..."
              echo "$CERTIFICATE_INGRESS_TEMPLATE" \
                | yq -y '.spec.commonName = "apps.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | yq -y '.spec.dnsNames[0] = "apps.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | yq -y '.spec.dnsNames[1] = "*.apps.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | yq -y '.spec.dnsNames[2] = "apps.'$TIMESTAMP'.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | oc apply -f -
              
              echo "Applying API Certificate..."
              echo "$CERTIFICATE_API_TEMPLATE" \
                | yq -y '.spec.commonName = "api.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | yq -y '.spec.dnsNames[0] = "api.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | yq -y '.spec.dnsNames[1] = "api.'$TIMESTAMP'.'$CLUSTERNAME'.'$BASEDOMAIN'"' - \
                | oc apply -f -

              echo "CertManager setup completed successfully."    
      restartPolicy: Never
      serviceAccountName: openshift-gitops-argocd-application-controller